\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{graphicx}
\DeclareGraphicsExtensions{.png}

\usepackage{titlesec}

\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection.}{0.3em}{}

\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection.}{0.3em}{}

\titlespacing{\section}{0pt}{*2}{*2}
\titlespacing{\subsection}{0pt}{*1}{*1}
\titlespacing{\subsubsection}{0pt}{*0}{*0}
\usepackage{listings}
\lstloadlanguages{Lisp}
\lstset{extendedchars=false,
	breaklines=true,
	breakatwhitespace=true,
	keepspaces = true,
	tabsize=2
}
\begin{document}


\section*{Отчет по лабораторной работе №\,3 
по курсу \guillemotleft  Функциональное программирование\guillemotright}
\begin{flushright}
Студент группы 8О-307 МАИ \textit{Вельтман Лина}, \textnumero 7 по списку \\
\makebox[7cm]{Контакты: {\tt  kluuo@mail.ru} \hfill} \\
\makebox[7cm]{Работа выполнена: 25.04.2020 \hfill} \\
\ \\
Преподаватель: Иванов Дмитрий Анатольевич, доц. каф. 806 \\
\makebox[7cm]{Отчет сдан: \hfill} \\
\makebox[7cm]{Итоговая оценка: \hfill} \\
\makebox[7cm]{Подпись преподавателя: \hfill} \\

\end{flushright}

\section{Тема работы}
Знаки и строки.

\section{Цель работы}
Научиться работать с литерами (знаками) и строками при помощи функций обработки строк и общих функций работы с последовательностями.

\section{Задание (вариант №37)}
Запрограммировать на языке Коммон Лисп функцию {\tt find-word}, принимающую два аргумента:
{\tt word} - строка, представляющая слово,
{\tt source} - текст.
Если слово найдено, функция должна возвращать два значения с помощью {\tt values}:
индекс начала данного слова в предложении,
номер первого предложения в тексте, в которое входит слово (нумерация с 0).
Если слово не найдено, функция должна вернуть NIL.\\


\section{Оборудование ПЭВМ студента}
Ноутбук MacBook Pro (13-inch, 2017), процессор 2.3GHz Intel Core i5, память: 8Gb, разрядность системы: 64.

\section{Программное обеспечение ЭВМ студента}
macOS Catalina 10.15.4, реализация языка SBCL 1.4.16, текстовый редактор Sublime Text 3.

\section{Идея, метод, алгоритм}
Точкой отсчета для меня была встроенная функция {\tt search}. Она позволяет найти заданную подпоследовательность в области поиска. Если вхождение было, то функция возвращает позицию первого вхождения в последовательности, в которой происходил поиск подпоследовательности, иначе возвращается {\tt nil}.
Отталкиваясь от этого, я решила последовательно проходить по строкам текста {\tt text} (задан как список, в котором хранятся строки - предложения текста), инкрементируя переменную отвечающую за количество предложений в тексте.
Далее для поиска индекса начала слова я написала функцию {\tt parsing\_str}, в которой вызывается функция {\tt search} для поиска заданного слова {\tt word} в рассматриваемом предложении {\tt sentence}, затем проверяется, что стоит после конца слова (если было найдено вхождение).
Если это пробел, знак табуляции, новая линия или знаки пунктуации, то найденное слово верное и возвращается индекс его начала, если нет, то сдвигаемся от найденной позиции на количество символов, равное длине слова. 
Затем вызываем еще одну функцию {\tt double\_find}, которая проверяет позицию начала вхождения, ведь найденное слово может быть всего лишь подстрокой какого-то слова, а это нам не подходит. 
Цикл прохода по всем предложениям текста в функции {\tt finding-the-word} работает до тех пор, пока функция {\tt search} не вернет позицию вхождения. 
Для проверки того, что вернула функция {\tt search} было решено использовать анонимную функцию, реализуемую с помощью лямбда-выражения, в которую в качестве аргумента передавалось возвращаемое значение функции {\tt search}. 
Если объект(позиция вхождения) существует, то есть не равно {\tt null}, то возвращается {\tt true}, иначе {\tt false}. 
Цикл прохода по тексту будет работать до тех пор, пока не закончатся предложения (то есть до конца списка) или, если возращаемое значение анонимной функции было {\tt true}, то есть мы нашли вхождение слова в каком-либо предложении. 
Далее происходит проверка на существование позиции вхождения, если она есть, то создается список, в котором хранятся позиция вхождения слова в предложение и номер предложения, в котором нашлось слово, иначе возвращается {\tt nil}, то есть вхождения заданного слова {\tt word} не было вовсе.

\section{Сценарий выполнения работы}

\section{Распечатка программы и её результаты}

\subsection{Исходный код}
\lstinputlisting{lab4_37.lisp}

\subsection{Результаты работы}
\lstinputlisting{log.txt}

\section{Дневник отладки}
\begin{tabular}{|c|c|c|c|}
\hline
Дата & Событие & Действие по исправлению & Примечание \\
\hline
\end{tabular}

\section{Замечания автора по существу работы}
В реализации мне помогла встроенная функции поиска подпоследовательностей  {\tt search} и {\tt lambda} - определяет анонимную функцию, она обычно используется, когда при определении новая функции не именуется. Это так же делает замысел программиста более очевидным, за счет того, что функция находится там же, где она используется.

\section{Выводы}
Я получила опыт работы со строками при помощи общих функций для строк и последовательностей. Также для выполнения данной лабораторной работы мне помогли знания, полученные в предыдущих работах.

\end{document}